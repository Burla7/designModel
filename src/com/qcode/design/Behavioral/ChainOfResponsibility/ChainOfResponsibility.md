# 职责链模式
**&emsp;&emsp;请求的链式处理，避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。职责链模式是一种对象行为型模式。**

**&emsp;&emsp;职责链模式并不创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。**
 
 具体处理者
 - 处理请求
 - 转发请求
 
 #### 1.纯的职责链模式
&emsp;&emsp;要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。

 #### 2.不纯的职责链模式
 &emsp;&emsp;允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收
  
#### 总结

* **问题**
   
   1. 处理类业务逻辑复杂，较为庞大，维护以及测试难度较大。
   2. 多个处理耦合严重，缺乏灵活性，违反开闭原则。
  
* **目的**
  
    避免发送者与接受者耦合在一起，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，实现请求发送者和请求处理者解耦。
* **解决方案**

    通过抽象处理者，将对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。
* **效果**

   实现低耦合，将每个处理对象连接成一条链，并且沿着这条链传递请求进行处理。
   职责链太长可能会导致维护不方便 如果业务比较复杂 可能会循环调用死循环。
   
   
   ### Demo介绍
   
   - Aoorover类为抽象管理类  主要功能为设置后继处理者以及抽象请求处理方法
   - Congress(董事会) Director(主任类) President(董事长) VicePresident（副董事长）
   - PurchaseRequest为采购单类  请求实体类
   - Client 为请求类   创建职责链以及请求单据审批。 
   
   低耦合 更改职责链只需要将后继处理者更改即可 并且将请求与处理分开。
   
  
  