# 原型模式
**&emsp;&emsp;使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式是一种对象创建型模式。**

**&emsp;&emsp;克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象**

 #### 1.浅克隆
&emsp;&emsp;在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制

 #### 2.深克隆
&emsp;&emsp;在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制

#### 总结

* **解决问题**
    
     提高大量相同或相似对象的创建效率，原型工具类有着良好的扩展性，创建简单，保存对象状态。
  
* **缺点**
  
     违反开闭原则  对已有类进行改造需要改造其源代码。深克隆需要每个子对象都支持深克隆。
     
### Demo介绍
- Prototype为克隆原型类 可以为抽象类接口或工具类 实现Cloneable 接口 继承或实现子类可以实现JAVA自带clong方法 
- ConcretePrototype类为 Prototype的实现类  实现clone方法
- CloneUtils类是实现深克隆工具类,里有clone方法通过Serializable实现深度克隆
- ChildrenPrototype类 是ConcretePrototype类的一个字段. 深克隆与浅克隆的区别为对象的引用型字段 是否为真正克隆 通过该类去测试
##### 原型管理器
- OfficialDocument  文档原型类 FAR与SRS实现该接口 
- PrototypeManager 为文档管理类 通过HashTable 以及原型类提供的克隆方法提供相对应的原型文档
尝试使用抽象类实现 但是继承的话感觉不太妥当 
 
 
 

 
  
  