# 简单工厂模式
**&emsp;&emsp;简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。**

**&emsp;&emsp;当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。**


#### 总结

* **解决问题** 

    - 解决对象的创建和使用耦合，代码量冗长，职责过重
    - 对将创建展示等过多职责集成一起的类进行提取。防止代码重复以及创建蔓延等。终结太多的业务逻辑实现创建不同的对象，将每个对象的创建解耦出来

* **缺点**
    - 限制较大，如构建不同的对象的差异性大，不适合使用建造者模式。
    - 需要定义很多的具体建造者，系统庞大。则理解难度和运行成本会增大。
    
     
* **优点**
    - 将对象和对象的构建过程解耦，使得相同的构建过程可以构建不同的对象。
    - 具体建造者为独立，扩展方便，符合开闭原则。
    - 对每个具体对象的构建都可以精细控制，创建过程更加清晰。
   
  
#####Demo介绍
- Actor为产品实体类
- ActorBuilder为产品建造抽象类  中定义了产品的几个不同组件的构建抽象方法 由具体构建类实现。
- ActorController为产品构建控制类，控制调用兑现的构建实现方法来构建对象（v1,0)  也可以在ActorBuilder中 返回产品对象的方法直接调用构建方法（v2.0）
- builderImpl包为具体构建类所在的包 实现了ActorBuilder中的构建抽象方法 从而构建出不同的产品
- decorator包内为装饰类 继承了ComponentDecorators 注入component对象 重写扩展display方法
- Client客户端类 先通过XMLUtil反射一个具体构建类，然后通过父类抽象构建类中的构建方法返回构建后的产品
- 钩子方法 通过抽象构建类 以及DevilBuilder实现 先于父类返回一个默认状态  在子类中重写状态 父类可以通过判断子类状态从而实现业务逻辑

将复杂对象的构建分为几个方法实现，抽象出抽象构建类，再由不同的具体构建类  调用抽象构建类的构建方法 只要传入不同的构建类 就可以通过相同的构建方法返回不同负责对象  

  