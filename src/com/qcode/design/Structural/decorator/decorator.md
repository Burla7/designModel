# 装饰模式
**&emsp;&emsp;动态地给一个对象增加一些额外的职责，就扩展对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式。**

**&emsp;&emsp;生成子类对象扩展不方便，尤其JAVA不支持多重继承，容易重复代码以及冗余类。复用机制的不合理回导致系统臃肿，多用关联少用继承。是一种替代继承的一种方式。**

**&emsp;&emsp;装饰模式可以在不改变一个对象本身功能的基础上给的对象增加额外的新行为。例如给照片套一个相框，再套一个花边**

 #### 1.透明装饰模式
&emsp;&emsp;完全针对抽象编程,透明性要求客户端不应该将对象声明为具体构建类，全部声明为抽象构件类型。 客户端可以一致地使用这些对象，无须关心它们的区别。

 #### 2.半透明装饰模式
&emsp;&emsp; 更加灵活 可以调用具体装饰类方法 为了能够调用到具体装饰类新增的业务方法，不得不用具体装饰类定义  不能实现对同一个对象的多次装饰

#### 总结

* **解决问题**
    
     不影响其他对象的情况下 以动态、透明的方式给单个对象添加职责。以及在当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承 
     
  
* **缺点**
  
     会产生许多的小对象，在一定程序上影响程序的性能（个人认为可以忽略）
     对于多次装饰的对象，排错应该需要逐级排查，比较繁琐。比继承更加灵活，但是起继承更容易出错。
     
* **优点**
    - 符合开闭原则 无须改变原有代码 并且对具体构件和装饰修改不会影响其他对象
    - 比继承更加灵活 不会导致类的个数几何增长
    - 对一个对象多次装饰 并且动态装饰
   
  
#####Demo介绍
- Component为抽象构件类  中有display展示方法
- ComponentDecorators为装饰父类  继承Component(不改变业务中返回的对象类型)  里面有构件字段对象 在构造方法中注入该构件 然后重写display方法  
- compents包内为构件类 继承了Component  类实现了display方法。
- decorator包内为装饰类 继承了ComponentDecorators 注入component对象 重写扩展display方法

通过利用继承机制。虽然装饰类是继承了抽象构件类，所做的行为是对构件类的原有方法进行扩展。个人感觉像是AOP，不同的是可以不断注入装饰类不断的进行扩展。Client中有透明模式与半透明模式 具体的区别为对象的声明
装饰者与被装饰者拥有共同的超类，继承的目的是继承类型，而不是行为

  